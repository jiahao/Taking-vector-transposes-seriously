\section{Introduction}

The terms ``vector'' and ``(one-dimensional) array'' appear so often as
synonyms that you may believe they actually are. In reality, computer
scientists and mathematicians mean different things by ``vectors''.  Computer
science is rife with terms such as ``vectorization'', ``vector machine,
``vector registers,'' and ``vector architecture'', where a ``vector''
simply means an ordered sequence of similar objects, or a one-dimensional
array. This meaning of ``vector'' is used in terms like ``vector operations''
to mean sorting, computing averages along an axis, and so on.
In contrast, mathematicians speak of ``vectors'' that are elements of
vector spaces. In the most abstract formulation, there is nothing said about
what the elements of a vector space are, only what operations are defined over
the vectors and the underlying scalar field.
In scientific computing, these two meanings of vectors can clash and cause
problems, particularly when working with matrices and vectors in the
conventions of numerical linear algebra in expressions like
$x^\prime Ay/x^\prime y$.

There are a few clues that a problem exists:


\begin{enumerate}

\item
Computer science terms like ``vectorization'' refer to one dimensional arrays
of homogeneous objects. Vectorized operations, like \code{sin(x)} for an array
\code{x}, have no need for the structure of a vector space.

\item
Programming language design issues regarding how to express linear algebra,
such as Julia's ``Taking vector transposes seriously''~\cite{julia4774} and
Python's ``A dedicated infix operator for matrix multiplication''~
\cite{numpy4351,Smith2014}, attract hundreds of comments from users expressing
a diversity of mutually incompatible opinions.

\item
Some computer languages cannot express identities familiar from linear algebra,
like $(ab')c = a(b'c)$ for vectors $a$, $b$ and $c$, using only multiplication
and transposition operations. Instead, the outer product $ab'$ must be written
as a call to a dedication function, such as
\code{numpy.outer}\cite{numpy.outer} in Python or
\code{Outer}\cite{Wolfram.Outer} in Mathematica.

\item
The original ``Matrix Laboratory''~\cite{Moler1980} had only
two-dimensional complex arrays, linear algebra, and broadcasting array
operations like \code{sin(x)}. All other functionality like sorting an array
were retrofit onto later versions of MATLAB, but every natural one dimensional
operation takes an optional \code{dim} argument to distinguish between
operations over rows from operations over columns. The default \code{dim}
choice occasionally risks confusion.

\item
The linear algebra literature can be classified by whether vectors
appear first (on or close to page 1) or whether matrices appear first.
In the former case, vectors live in a vector space; in the latter,
we have vectors that are matrices with one row or column.

\item
Programming languages do not consistently define what it means to transpose a vector. They can be classified by whether the result is the identity (a no-op), an error, a $1\times n$ matrix, or a value of a special row vector type.

\item
The scalar product $u^\prime v$ can be written as both \code{u.T @ v} and
\code{u @ v} in NumPy/Python; both produce a scalar. The analogous R code, \code{u\%*\%v}, produces a $1\times1$ matrix.

\item
A matrix times a vector is a vector, except in R, where the result of \code{A \%*\% b} is a matrix.

\item
A two dimensional array can be recursively defined is an array of arrays. A matrix cannot be defined recursively, but instead is a row vector of column vectors or a column vector of row vectors, never a row vector of row vectors or a column vector of column vectors.

\item
Matrix multiplication $C=AB$, is often defined in a first course in linear algebra as taking the scalar product of rows of $A$ with columns of $B$.
In MATLAB, we can express the computation of \code{C(i,j)} as \code{A(i,:)*B(:,j)}, but not with \code{u=A(i,:);v=B(:,j);u'v}, which returns an error.
In R, the analogous \code{A[i,] \%*\% B[,j]} returns a $1\times1$ matrix.
In NumPy/Python, the analogous \code{A[i-1,:] @ B[:,j-1]} returns a scalar.
Furthermore, this definition is sound for real matrices but is ambiguous for complex matrices and matrices over non-self-dual vector spaces.
The MATLAB code \code{dot(A(i,:),B(:,j))} returns the wrong answer for complex matrices.

\item
In the mathematical literature, $1\times 1$ matrices are often identified with scalars, and $n\times 1$ matrices are often identified with vectors. However, MATLAB is the only programming language used in scientific computing which makes these identifications. All other languages require users to convert between $1\times 1$ matrices and scalars, and $n\times 1$ matrices and vectors explicitly.

\end{enumerate}


These examples illustrate how computers have trouble with abstractions that humans, to a fault, are so good at overlooking. In fact, we did not initially think that this paper was actually worth writing, until we dug into the details. Decades after APL made multidimensional arrays first class objects, and MATLAB made Householder notation popular in computer code, we recently reached an inescapable conclusion, one we preferred not to believe, that vectors, in the sense of computer languages, and linear algebra vectors have serious coexistence issues.

This paper is targeted to those who speak the language of linear algebra and
also use a computer language. The linear algebra world has grown used to
operations such as $x^\prime Ay/x^\prime y$.(x’*A*y)/(x’*y), while the
non-linear algebra world considers array operations such as sorting, taking a
mean, sort(x) or mean(x) etc. In this paper, we argue that it is impossible to
have our beloved Householder notation $(x'Ay)/(x'y)$ and one dimensional arrays
in the same language without some sort of compromise.

In Sec.~\ref{sec:householder}, we examine which embeddings are implicit in linear algebraic expressions like inner products $u^T v$, outer products $u v^T$, and bilinear forms $u^T A v$, which are expressed in Householder notation~\cite{Householder1953,Householder1955} which is familiar to practitioners of numerical linear algebra today.
In Sec.~\ref{sec:arrays}, we review the use of vectors as arrays in computer science.
In Sec.~\ref{sec:linalghistory}, we review the historical development of vectors, matrices and linear algebra in mathematics.


\subsection{Introduction (v0)}

Matrices and vectors are fundamental concepts for both computer science
~\cite{Knuth1967,Pratt2001} and computational
science~\cite{Strang2003,Trefethen1997}. Nevertheless, the terms ``vector'' and
``matrix'' mean different things in the contexts of data structures and linear
algebra. As data structures, they are simply arrays, whereas as linear
algebraic objects, vectors are elements of a vector space and matrices are linear transformations.
When we represent linear algebra vectors and linear algebra transformation in a basis,
we obtain the familiar containers we know simply as vectors and matrices.



Computer science focuses primarily on the homogeneous container semantics of
vectors and matrices. Oftentimes they are considered synonymous with arrays of
rank 1 and 2 respectively. The seminal work of~\cite{Iliffe1961} says
%
\begin{quote}
``Depending on the organization of the array it may
be treated as a \textit{set}, a \textit{vector}, or a \textit{matrix}.''
\end{quote}
%
The classic~\cite{Knuth1967} focuses only on indexing semantics; the index
entry for ``two-dimensional array'' cross-references the entry for ``matrix''.
Even today, the conflation persists. A modern textbook on programming language
design writes~\cite[p. 215]{Pratt2001}:
%
\begin{quote}
A vector is a one-dimensional array; a matrix composed of rows and columns of
components is a two-dimensional array[.]
\end{quote}

%PZ p 217 also has a nice description of linear indexing semantics adopted from
%Fortran. Slicing came from PL/I.

In contrast, vectors and matrices in linear algebra are defined by their
algebraic properties, such as inner products and matrix-vector products.

The aim of this paper is to identify if and when the semantics of array
indexing and linear algebra may conflict.
